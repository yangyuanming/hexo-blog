[{"title":"maven生命周期和插件","url":"/post/b37b3bbf.html","content":"\n## maven生命周期\n\nmaven抽象出了3套生命周期，其具体实现是依赖于[maven插件](http://maven.apache.org/plugins/index.html)。每套生命周期是相互独立的，都由一组阶段(Phase)组成。每套生命周期中的阶段是有顺序的，后面阶段依赖于前面的阶段，执行后面阶段会自动执行之前的阶段，但不会触发不同生命周期的阶段。\n\n**下面是三个生命周期及其包含的阶段。**\n\n### Clean Lifecycle \n清理项目，在进行真正的构建之前进行一些清理工作。\n\n*  pre-clean     执行clean前需要完成的工作  \n\n*  clean     clean上一次构建生成的所有文件  \n\n*  post-clean    执行clean后需要立刻完成的工作  \n \n    \n>这里的clean就是指的mvn clean。在一套生命周期内，运行某个阶段会自动按序运行之前阶段，mvn clean=mvn pre-clean clean\n\n<!--more-->\n\n### Default Lifecycle\n构建的核心部分，编译，测试，打包，部署等等。\n\n* validate      验证项目是否正确，并且所有必要的信息可用于完成构建过程\n\n* initialize    建立初始化状态，例如设置属性\n\n* generate-sources\n     \n* process-sources \n     \n* generate-resources\n\n* process-resources     复制并处理资源文件，至目标目录，准备打包。\n\n* compile     编译项目的源代码。\n\n* process-classes\n\n* generate-test-sources\n \n* process-test-sources \n\n* generate-test-resources\n\n* process-test-resources     复制并处理资源文件，至目标测试目录。\n\n* test-compile     编译测试源代码。\n\n* process-test-classes\n\n* test     使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。\n\n* prepare-package\n\n* package     提取编译后的代码，并在其分发格式打包，如JAR，WAR或EAR文件\n\n* pre-integration-test     完成执行集成测试之前所需操作。例如，设置所需的环境\n\n* integration-test\n\n* post-integration-test     完成集成测试已全部执行后所需操作。例如，清理环境\n\n* verify        运行任何检查，验证包是有效的，符合质量审核规定\n\n* install     将包安装至本地仓库，以让其它项目依赖。\n\n* deploy     将最终的包复制到远程的仓库，以让其它开发人员与项目共享    \n    \n### Site Lifecycle   \n生成项目报告，站点，发布站点。\n\n* pre-site     执行一些需要在生成站点文档(html)之前完成的工作\n\n* site     生成项目信息的站点文档\n\n* post-site     执行一些需要在生成站点文档之后完成的工作，并且为部署做准备\n\n* site-deploy     将生成的站点文档部署到特定的服务器上\n\n## 插件\n\n\n## 参考资料\n\n>http://blog.sina.com.cn/s/blog_e01142dc0102wup3.html\n\n\n","tags":["maven插件"],"categories":["maven"]},{"title":"maven常用构建命令及库的概念","url":"/post/fcecdefc.html","content":"\n## maven常用构建命令\n1. 查看maven版本：mvn -v\n2. 编译：mvn compile\n3. 打包：mvn package\n4. 测试：mvn test\n5. 删除target目录：mvn clean\n6. 安装jar包到本地仓库：mvn install  \n<!--more-->\n7. 自动建立目录结构的两种方式：\n\n* mvn archetype:generate 按指示输入信息\n\n* mvn archetype:generate  \n-DgroupId=网址+项目名  \n-DartifactId=项目名-模块名  \n-Dversion=版本号  \n-Dpackage=代码包名\n\n-------\n\n## 构件、仓库、镜像仓库\n\n### 构件\n\npom.xml配置文件中的dependency，包含构件坐标等信息。\n    \n### 仓库(repository)\n分为本地仓库和远程仓库。先去本地仓库查询构件，如果没有就去远程仓库下载。\n\n\n> maven提供了一个默认的全球中央仓库，解压lib/maven-model-builder-version.jar，可以发现pom-4.0.0.xml在org/apache/maven/model下,pom-4.0.0.xml中配置了该仓库，所有项目的pom.xml都会继承该xml,默认就使用了该全球中央仓库。\n\n**中央仓库配置如下：**\n\n```xml\n<repository>\n      <id>central</id>\n      <name>Central Repository</name>\n      <url>https://repo.maven.apache.org/maven2</url>\n      <layout>default</layout>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n</repository>\n```\n\n\n### 镜像仓库\n配置远程仓库的镜像，所有针对原仓库的访问将转到镜像仓库，原仓库的url设置无效。\n\n\n* conf/settings.xml中配置镜像仓库，镜像可以有多个。\n\n* mirror的mirrorOf不能和任何一个mirror的id相同。  \n\n* mirrorOf配置的是该镜像所匹配的远程仓库(id)。拦截对应的远程仓库，使所有针对原仓库的访问将转到镜像仓库。\n\n* mirrorOf可以配置多个值，用逗号隔开\n\n> 默认是没有配置mirror的，为了加速构件和插件的下载速度，我配置了一个阿里云的mirror，mirrorOf配置的是central，则id是central的仓库(中央仓库)将会转到阿里云的镜像下载构件，原仓库的url设置将失效。\n\n```xml\n<mirror>\n        <id>nexus-aliyun</id>\n        <mirrorOf>central</mirrorOf>\n        <name>Nexus aliyun</name>\n        <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n</mirror>\n```\n\n\n* mirrorOf的值设置\n\n    *  **rep1**:代表这个镜像仅仅针对rep1这个库。如果存在多个镜像的mirrorOf值都包含rep1，则按顺序匹配。\n\n    * **\\***:代表匹配所有的库。注意maven会优先匹配mirrorOf值与仓库id完全相同的镜像。例如id为rep1的仓库会优先匹配mirrorOf也为rep1的镜像，如果没有才会匹配mirrorOf为*的镜像。\n    * **\\*,!rep1**:匹配所有的库，除了rep1 \n\n    * **external:\\***:代表匹配任意不在localhost上的仓库，或不是基于文件的仓库。这个主要是看repository中的url判断的。\n\n### 更改本地仓库位置\n\n> maven下载的构件默认放在~/.m2/repository下面，其中~代表用户目录。可以在conf/settings.xml中自定义本地仓库的位置。\n\n* 从文档注释中复制localRepository标签，粘贴，填入自定义目录\n\n```xml\n<localRepository>/Users/yuanming/maven_repo</localRepository>\n```\n\n* 备份settings.xml到maven_repo文件夹(自定义仓库文件夹)，在IDE中设置settings file的路径为备份的settings.xml的路径。以后更新maven，不用重新配置settings.xml。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["maven库"],"categories":["maven"]}]
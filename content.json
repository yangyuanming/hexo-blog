{"pages":[{"title":"关于","text":"IMIS,GDUT后台开发，Java Web熟悉ssm框架","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"Links","text":"我的github","link":"/links/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"归档","text":"","link":"/timeline/index.html"}],"posts":[{"title":"maven(一):构建命令、构件和库","text":"maven常用构建命令 查看maven版本：mvn -v 编译：mvn compile 打包：mvn package 测试：mvn test 删除target目录：mvn clean 安装jar包到本地仓库：mvn install 自动建立目录结构的两种方式： mvn archetype:generate 按指示输入信息 mvn archetype:generate 1234-DgroupId=网址+项目名 -DartifactId=项目名-模块名 -Dversion=版本号 -Dpackage=代码包名 构件、仓库、镜像仓库构件定义 在Maven中，任何依赖(jar包,tomcat等)、插件，或构建的输出都可成为构件。 Maven在某个统一的位置存储所有项目的共享的构件，这个统一的位置，我们就称之为仓库。（仓库就是存放依赖和插件的地方） 任何的构件都有唯一的坐标，Maven根据这个坐标定义了构件在仓库中的唯一存储路径。 坐标的组成： groupId 当前Maven构件隶属的项目名。实际开发中，项目往往会模块化开发，如spring-core,spring-aop等，他们都是Spring项目下不同的模块。命名方式与Java包名类似，通常是项目名+域名的反向书写。(必须) artifactId：隶属项目中的模块名。(必须) version：当前版本。(必须) packaging：打包方式，如jar,war… 。默认为jar(必须) classifier：帮助定义构建输出的一些附属构件。如spring-core.jar，还生成有文档javadoc.jar，源码sources.jar。 Maven构件在仓库中的存储路径 基于groupId准备路径，将句点分隔符转成路径分隔符，就是将 “.” 转换成 “/“ ; example： org.testng —&gt;org/testng 基于artifactId准备路径，将artifactId连接到后面：org/testng/testng 使用version准备路径，将version连接到后面：org/testng/testng/5.8 将artifactId于version以分隔符连字号连接到后面：org/testng/testng/5.8/tesng-5.8 判断如果构件有classifier，就要在 第4项 后增加 分隔符连字号 再加上 classifier，org/testng/testng/5.8/tesng-5.8-jdk5 检查构件的extension，如果extension存在，则加上句点分隔符和extension，而extension是由packing决定的，org/testng/testng/5.8/tesng-5.8-jdk5.jar 特性 构件具有依赖传递。例如：项目依赖构件A，而构件A又依赖B，Maven会将A和B都视为项目的依赖。 依赖之间存在版本冲突时，Maven会依据 “短路优先” 原则加载构件。如果引用的路径长度相同时，遵循“声明优先”的原则。此外，我们也可以在POM.XML中，使用显式排除某个版本的依赖，以确保项目能够运行。 项目依赖构件A和B，构件A → C → D(version:1.0.0)，构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.1.0)。 项目依赖构件A和B，构件A → D(version:1.0.0)， 构件B → D(version:1.1.0)，此时，Maven会优先解析加载D(version:1.0.0)。 构件的依赖范围。Maven在项目的构建过程中，会编译三套classpath，分别对应：编译期，运行期，测试期。而依赖范围，就是为构件指定它可以作用于哪套classpath。 仓库(repository)分为本地仓库和远程仓库。先去本地仓库查询构件，如果没有就去远程仓库下载。 maven提供了一个默认的全球中央仓库，解压lib/maven-model-builder-version.jar，可以发现pom-4.0.0.xml在org/apache/maven/model下,pom-4.0.0.xml中配置了该仓库，所有项目的pom.xml都会继承该xml,默认就使用了该全球中央仓库。用户可以在pom.xml中自定义远程仓库。 中央仓库配置如下： 123456789&lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt;&lt;/repository&gt; 镜像仓库配置远程仓库的镜像，所有针对原仓库的访问将转到镜像仓库，原仓库的url设置无效。 conf/settings.xml中配置镜像仓库，镜像可以有多个。 mirror的mirrorOf不能和任何一个mirror的id相同。 mirrorOf配置的是该镜像所匹配的远程仓库(id)。拦截对应的远程仓库，使所有针对原仓库的访问将转到镜像仓库。 mirrorOf可以配置多个值，用逗号隔开 默认是没有配置mirror的，为了加速构件和插件的下载速度，我配置了一个阿里云的mirror，mirrorOf配置的是central，则id是central的仓库(中央仓库)将会转到阿里云的镜像下载构件，原仓库的url设置将失效。 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; mirrorOf的值设置 rep1:代表这个镜像仅仅针对rep1这个库。如果存在多个镜像的mirrorOf值都包含rep1，则按顺序匹配。 *:代表匹配所有的库。注意maven会优先匹配mirrorOf值与仓库id完全相同的镜像。例如id为rep1的仓库会优先匹配mirrorOf也为rep1的镜像，如果没有才会匹配mirrorOf为*的镜像。 *,!rep1:匹配所有的库，除了rep1 external:*:代表匹配任意不在localhost上的仓库，或不是基于文件的仓库。这个主要是看repository中的url判断的。 更改本地仓库位置 maven下载的构件默认放在~/.m2/repository下面，其中~代表用户目录。可以在conf/settings.xml中自定义本地仓库的位置。 从文档注释中复制localRepository标签，粘贴，填入自定义目录 1&lt;localRepository&gt;/Users/yuanming/maven_repo&lt;/localRepository&gt; 备份settings.xml到maven_repo文件夹(自定义仓库文件夹)，在IDE中设置settings file的路径为备份的settings.xml的路径。以后更新maven，不用重新配置settings.xml。 参考资料 易枫,Maven之构件chengfangjunmy,Maven","link":"/post/25edb67f.html"},{"title":"maven(三):pom.xml详解","text":"pom.xml详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--&gt; &lt;parent&gt; &lt;!--被继承的父项目的构件标识符--&gt; &lt;artifactId&gt;&lt;artifactId/&gt; &lt;!--被继承的父项目的全球唯一标识符--&gt; &lt;groupId&gt;&lt;groupId/&gt; &lt;!--被继承的父项目的版本--&gt; &lt;version&gt;&lt;version/&gt; &lt;!-- 元素relativePath表示了**父模块POM**的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。当项目构建时，Maven会首先根据relativePath检查父pom，然后在本地仓库，最后在远程仓库寻找父项目的pom。此例子父模块parent和子模块在同一级目录下。--&gt; &lt;relativePath&gt;&lt;relativePath/&gt; &lt;/parent&gt; &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目,一般是网址的反写+项目名。构建时生成的路径也是由此生成，如com.yangyuanming.blog生成的相对路径为：/com/yangyuanming/blog--&gt; &lt;groupId&gt;com.yangyuanming.blog&lt;/groupId&gt; &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件,通常由”项目名-模块名“构成。换句话说，你不能有两个不同的项目拥有同样的artifactId和groupId；在某个特定的groupId下，artifactId也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。--&gt; &lt;artifactId&gt;blog-v1&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号。版本号包括：snapshot(快照)、alpha(内部测试)、beta(公测)、release(稳定)、GA(正式发布) --&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目的名称, Maven产生的文档用--&gt; &lt;name&gt;Yang Yuanming,s Blog&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;https://yangyuanming.com&lt;/url&gt; &lt;!-- 项目的详细描述, Maven产生的文档用。当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签），不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--&gt; &lt;description&gt;A blog project&lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。--&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本--&gt; &lt;maven&gt;&lt;maven/&gt; &lt;/prerequisites&gt; &lt;!--项目的问题管理系统，如Bugzilla, Jira, Scarab等--&gt; &lt;issueManagement&gt; &lt;!--问题管理系统的名字--&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL--&gt; &lt;url&gt;http://jira.xxx.com/xxx&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息--&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum--&gt; &lt;system&gt;&lt;system/&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--&gt; &lt;url&gt;&lt;url/&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--&gt; &lt;notifier&gt; &lt;!--传送通知的途径--&gt; &lt;type/&gt; &lt;!--发生错误时是否通知--&gt; &lt;sendOnError/&gt; &lt;!--构建失败时是否通知--&gt; &lt;sendOnFailure/&gt; &lt;!--构建成功时是否通知--&gt; &lt;sendOnSuccess/&gt; &lt;!--发生警告时是否通知--&gt; &lt;sendOnWarning/&gt; &lt;!--不赞成使用。通知发送到哪里--&gt; &lt;address/&gt; &lt;!--扩展配置项--&gt; &lt;configuration/&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--&gt; &lt;inceptionYear&gt;&lt;inceptionYear/&gt; &lt;!--项目相关邮件列表信息--&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--&gt; &lt;mailingList&gt; &lt;!--邮件的名称--&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;post&gt;chaibozhou@163.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;subscribe&gt;chaibozhou@163.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;unsubscribe&gt;chaibozhou@163.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL--&gt; &lt;archive&gt;chaibozhou@163.com&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表--&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息--&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符--&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt; &lt;!--项目开发者的全名--&gt; &lt;name&gt;chaimm&lt;/name&gt; &lt;!--项目开发者的email--&gt; &lt;email&gt;chaibozhou@163.com&lt;/email&gt; &lt;!--项目开发者的主页的URL--&gt; &lt;url&gt;&lt;url/&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--&gt; &lt;roles&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织--&gt; &lt;organization&gt;demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL--&gt; &lt;organizationUrl&gt;https://yangyuanming.com&lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等--&gt; &lt;properties&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。--&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表--&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素--&gt; &lt;contributor&gt;&lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--&gt; &lt;license&gt; &lt;!--license用于法律上的名称--&gt; &lt;name&gt;Apache 2&lt;/name&gt; &lt;!--官方的license正文页面的URL--&gt; &lt;url&gt;&lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖--&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息--&gt; &lt;comments&gt;&lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD--&gt; &lt;tag&gt;&lt;tag/&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--&gt; &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用--&gt; &lt;organization&gt; &lt;!--组织的全名--&gt; &lt;name&gt;demo&lt;/name&gt; &lt;!--组织主页的URL--&gt; &lt;url&gt;https://yangyuanming.com&lt;/url&gt; &lt;/organization&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;!--该元素配置了构建输出文件的存放目录，默认${project.basedir}/target--&gt; &lt;directory&gt;&lt;/directory&gt; &lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。--&gt; &lt;finalName&gt;&lt;finalName/&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。默认${project.basedir}/src/main/java--&gt; &lt;sourceDirectory&gt;&lt;sourceDirectory/&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。${project.basedir}/src/main/scripts--&gt; &lt;scriptSourceDirectory&gt;&lt;scriptSourceDirectory/&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。默认${project.basedir}/src/test/java--&gt; &lt;testSourceDirectory&gt;&lt;testSourceDirectory/&gt; &lt;!--被编译过的应用程序class文件存放的目录。默认${project.build.directory}/classes--&gt; &lt;outputDirectory&gt;&lt;outputDirectory/&gt; &lt;!--被编译过的测试class文件存放的目录。默认${project.build.directory}/test-classes--&gt; &lt;testOutputDirectory&gt;&lt;testOutputDirectory/&gt; &lt;!--使用来自该项目的一系列构建扩展--&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。--&gt; &lt;extension&gt; &lt;!--构建扩展的groupId--&gt; &lt;groupId&gt;&lt;groupId/&gt; &lt;!--构建扩展的artifactId--&gt; &lt;artifactId&gt;&lt;artifactId/&gt; &lt;!--构建扩展的版本--&gt; &lt;version&gt;&lt;version/&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt; &lt;defaultGoal&gt;&lt;defaultGoal/&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关的资源信息--&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt; &lt;targetPath&gt;&lt;targetPath/&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt; &lt;filtering&gt;&lt;filtering/&gt; &lt;!--描述存放资源的目录，该路径相对POM路径。默认${project.basedir}/src/main/resources--&gt; &lt;directory&gt;&lt;directory/&gt; &lt;!--包含的模式列表，例如**/*.xml.--&gt; &lt;includes&gt;&lt;includes/&gt; &lt;!--排除的模式列表，例如**/*.xml--&gt; &lt;excludes&gt;&lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的资源信息--&gt; &lt;testResource&gt; &lt;targetPath&gt;&lt;targetPath/&gt; &lt;filtering&gt;&lt;filtering/&gt; &lt;!--默认${project.basedir}/src/test/resources--&gt; &lt;directory&gt;&lt;directory/&gt; &lt;includes&gt;&lt;includes/&gt; &lt;excludes&gt;&lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt; &lt;filters&gt;&lt;filters/&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID--&gt; &lt;groupId&gt;&lt;groupId/&gt; &lt;!--插件在仓库里的artifact ID--&gt; &lt;artifactId&gt;&lt;artifactId/&gt; &lt;!--被使用的插件的版本（或版本范围）--&gt; &lt;version&gt;&lt;version/&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt; &lt;extensions&gt;&lt;extensions/&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息--&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt; &lt;id&gt;&lt;id/&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt; &lt;phase&gt;&lt;phase/&gt; &lt;!--配置的执行目标--&gt; &lt;goals&gt;&lt;goals/&gt; &lt;!--配置是否被传播到子POM--&gt; &lt;inherited&gt;&lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited&gt;&lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表--&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;groupId/&gt; &lt;artifactId&gt;&lt;artifactId/&gt; &lt;version&gt;&lt;version/&gt; &lt;extendsions&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;&lt;id/&gt; &lt;phase&gt;&lt;phase/&gt; &lt;goals&gt;&lt;goals/&gt; &lt;inherited&gt;&lt;inherited/&gt; &lt;configuration&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals&gt;&lt;goals/&gt; &lt;inherited&gt;&lt;inherited/&gt; &lt;configuration&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt; &lt;modules&gt;&lt;modules/&gt; &lt;!--发现依赖和扩展的远程仓库列表。--&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息--&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载--&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled&gt;&lt;enabled/&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--&gt; &lt;updatePolicy&gt;&lt;updatePolicy/&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--&gt; &lt;checksumPolicy&gt;&lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled/&gt; &lt;updatePolicy/&gt; &lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称--&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt; &lt;pluginRepository&gt; ...... &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID--&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID--&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。--&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile:编译依赖范围。如果没有指定，就会默认使用该依赖范围，使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。此外，这些依赖关系会传播到依赖项目。 - test:测试依赖范围。使用该范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是JUnit,它只是在编译测试代码和运行测试的时候需要该依赖。这个范围是不可传递的。 - provided：已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试的classpath有效，但是在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要改依赖，但是在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。该依赖不可传递。 - runtime:运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但是编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在测试或者运行项目的时候才需要实现上述接口的JDBC驱动。 - import(Maven 2.0.9及以上)：导入依赖范围。仅限于在&lt;dependencyManagement&gt;中引入的依赖，依赖的类型必须为pom，才能声明scope为import。对于被导入的pom也必须配置有&lt;dependencyManagement&gt;,配置有对依赖的管理。该依赖范围不会对三种classpath产生实际的影响,不参与限制依赖关系的传递性。引进方其实引进的是被引进方pom.xml中&lt;dependencyManagement&gt;的配置。 - system:系统依赖范围，该范围与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显式的指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析，而且往往与本机系统绑定，可能造成构建的不可移植，因此需要谨慎使用。--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system scope使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。--&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。如果为true，需要显式引用--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--&gt; &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt; &lt;excludeDefaults&gt;&lt;excludeDefaults/&gt; &lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。--&gt; &lt;outputDirectory&gt;&lt;outputDirectory/&gt; &lt;!--使用的报表插件和他们的配置。--&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID--&gt; &lt;groupId&gt;&lt;groupId/&gt; &lt;!--报表插件在仓库里的artifact ID--&gt; &lt;artifactId&gt;&lt;artifactId/&gt; &lt;!--被使用的报表插件的版本（或版本范围）--&gt; &lt;version&gt;&lt;version/&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited&gt;&lt;inherited/&gt; &lt;!--报表插件的配置--&gt; &lt;configuration&gt;&lt;configuration/&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到--&gt; &lt;id&gt;&lt;id/&gt; &lt;!--产生报表集合时，被使用的报表的配置--&gt; &lt;configuration&gt;&lt;configuration/&gt; &lt;!--配置是否被继承到子POMs--&gt; &lt;inherited&gt;&gt;&lt;inherited/&gt; &lt;!--这个集合里使用到哪些报表--&gt; &lt;reports/&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息--&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--&gt; &lt;uniqueVersion&gt;&lt;uniqueVersion/&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;banseon maven2&lt;/name&gt; &lt;url&gt;file://${basedir}/target/deploy&lt;/url&gt; &lt;layout/&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion&gt;&lt;uniqueVersion/&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt; &lt;layout&gt;&lt;layout/&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息--&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--&gt; &lt;id&gt;banseon-site&lt;/id&gt; &lt;!--部署位置的名称--&gt; &lt;name&gt;business api website&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式--&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--&gt; &lt;downloadUrl&gt;&lt;downloadUrl/&gt; &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--&gt; &lt;relocation&gt; &lt;!--构件新的group ID--&gt; &lt;groupId&gt;&lt;groupId/&gt; &lt;!--构件新的artifact ID--&gt; &lt;artifactId&gt;&lt;artifactId/&gt; &lt;!--构件新的版本号--&gt; &lt;version&gt;&lt;version/&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。--&gt; &lt;message&gt;&lt;message/&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。--&gt; &lt;status/&gt; &lt;/distributionManagement&gt; &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。--&gt; &lt;properties&gt;&lt;properties/&gt; &lt;!--在列的项目构建profile，如果被激活，会修改构建处理--&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理--&gt; &lt;profile&gt; &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--&gt; &lt;id&gt;&lt;id/&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标志,当值为true，如果没有被指定激活的profile，该profile就会被默认被激活--&gt; &lt;activeByDefault&gt;true&lt;activeByDefault/&gt; &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt; &lt;jdk&gt;&lt;jdk/&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字--&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 'windows')--&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本--&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt; &lt;property&gt; &lt;!--激活profile的属性的名称--&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值--&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。--&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。--&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--构建项目所需要的信息。参见build元素--&gt; &lt;build&gt; &lt;defaultGoal/&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath/&gt; &lt;filtering/&gt; &lt;directory/&gt; &lt;includes/&gt; &lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath/&gt; &lt;filtering/&gt; &lt;directory/&gt; &lt;includes/&gt; &lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory/&gt; &lt;finalName/&gt; &lt;filters/&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt; &lt;artifactId/&gt; &lt;version/&gt; &lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt; &lt;phase/&gt; &lt;goals/&gt; &lt;inherited/&gt; &lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt; &lt;inherited/&gt; &lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt; &lt;artifactId/&gt; &lt;version/&gt; &lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt; &lt;phase/&gt; &lt;goals/&gt; &lt;inherited/&gt; &lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt; &lt;inherited/&gt; &lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt; &lt;modules&gt;&lt;modules/&gt; &lt;!--发现依赖和扩展的远程仓库列表。--&gt; &lt;repositories&gt; &lt;!--参见repositories/repository元素--&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled&gt;&lt;enabled/&gt; &lt;updatePolicy&gt;&lt;updatePolicy/&gt; &lt;checksumPolicy&gt;&lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled/&gt; &lt;updatePolicy/&gt; &lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;id/&gt; &lt;name/&gt; &lt;url/&gt; &lt;layout/&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled/&gt; &lt;updatePolicy/&gt; &lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled/&gt; &lt;updatePolicy/&gt; &lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;id/&gt; &lt;name/&gt; &lt;url/&gt; &lt;layout/&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt; &lt;reports/&gt; &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--&gt; &lt;reporting&gt; ...... &lt;/reporting&gt; &lt;!--参见dependencyManagement元素--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--参见distributionManagement元素--&gt; &lt;distributionManagement&gt; ...... &lt;/distributionManagement&gt; &lt;!--参见properties元素--&gt; &lt;properties/&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/project&gt; 参考资料 hcmony,Maven使用详解，非常详细","link":"/post/9d66f127.html"},{"title":"maven(六):依赖管理和插件管理","text":"依赖管理继承dependencyManagement通过继承可以减少子模块的重复配置，但会存在继承多余依赖的问题。maven提供了 &lt;dependencyManagement&gt;,在&lt;dependencyManagement&gt;元素下的依赖声明不会引入实际的依赖，不过他能够管理&lt;denpendencies&gt;下的依赖。父模块定义&lt;dependencyManagement&gt;，子模块可以继承父模块，使用父模块依赖配置，同时保证子模块依赖使用的灵活度。举个例子，在父模块中定义： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;properties&gt; &lt;springframework.version&gt;2.5.6&lt;/springframework.version&gt; &lt;junit.version&gt;4.7&lt;/junit.version&gt; &lt;javax.mail.version&gt;1.4.1&lt;/javax.mail.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${springframework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${springframework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${springframework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${springframework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;${javax.mail.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 上面在父模块的&lt;/dependencyManagement&gt;中定义了&lt;dependencies&gt;,依赖的版本号做了归并处理，方便后期修改。该配置不会引入依赖，子项目可以继承该配置。下面是子项目的配置 12345678910111213141516171819202122232425262728293031&lt;properties&gt; &lt;greenmail.version&gt;1.3.1b&lt;/greenmail.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.icegreen&lt;/groupId&gt; &lt;artifactId&gt;greenmail&lt;/artifactId&gt; &lt;version&gt;${greenmail.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 可以看到上面子模块的pom.xml的配置，子模块继承了父模块&lt;dependencyManagement&gt;的配置，但这只是依赖的配置，并不会真的引入依赖。对于父模块&lt;dependencyManagement&gt;已经配置的依赖，子模块仍然需要显式引入，但版本号不需要再定义，会直接使用父模块中定义的。相比于在父模块引入依赖，子模块全部继承的方式，这种方式更加灵活，可以自由引入所需依赖，虽然增加了显式引入的工作量，但避免了引入多余依赖。在多模块的项目中，这种方式可以灵活引入依赖和统一管理依赖配置。 &lt;dependencyManagement&gt;是多模块项目中必不可少的，因为它可以有效地帮助我们维护依赖的一致性 引进dependencyManagement除了继承的方式引入&lt;dependencyManagement&gt;，还可以引入import scope依赖的方式。被引进的依赖类型必须为pom，并且pom.xml中配置了&lt;dependencyManagement&gt;，在引进方的pom.xml中的&lt;dependencyManagement&gt;中才可以引入 import scope依赖，引进方其实引进的是被引进方pom.xml中&lt;dependencyManagement&gt;的配置。为什么要使用引入import scope依赖的方式?maven和java一样，无法使用多重继承。如果遇到一个模块很多的项目，如果都继承同一个父模块，那么将会在父模块的&lt;dependencyManagement&gt;中配置大量的依赖。如果想进行将这些依赖分类以进行更加清晰的管理，按照这种方式是不行的。在子模块&lt;dependencyManagement&gt;中引入import scope依赖可以解决这个为题。步骤如下： 在专门管理依赖的模块的pom中定义&lt;dependencyManagement&gt; 在需要引入依赖管理的模块的&lt;dependencyManagement&gt;以import scope的方式引入该pom 可以看出，第一步跟使用继承的方式一样，定义专门管理依赖的pom，定义&lt;dependencyManagement&gt;，只是第二步不同，依赖管理引入方不是通过继承的方式引入依赖管理的配置，而是在&lt;dependencyManagement&gt;中以引入import scope依赖的方式获得依赖管理的配置。下面例子示范：定义用于依赖管理的pom12345678910111213141516171819202122232425&lt;projectxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:shemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yangyuanming&lt;/groupId&gt; &lt;artifactId&gt;sample-dependency-infrastructure&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactid&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.8.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactid&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 在需要引入依赖管理的模块中采用import scope的方式导入该pom 1234567891011121314151617181920&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.yangyuanming&lt;/groupId&gt; &lt;artifactid&gt;sample-dependency-infrastructure&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactid&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactid&gt;log4j&lt;/artifactId&gt; &lt;/dependency&gt; 跟继承一样，导入的&lt;dependencyManagement&gt;，并不会真的引入依赖，还是需要再显式引入依赖。相比于继承的方式，采用import scope依赖的方式可以更好分类管理依赖。父模块的pom将会更清晰，不再对依赖进行管理，交给专门的packaging为pom的来管理依赖。我们可以定义多个用于管理依赖的pom，进行更加细化的依赖管理,可以满足多模块的需求，实现清晰化管理依赖。 dependencyManagement和dependencies区别 &lt;dependencies&gt;相对于&lt;dependencyManagement&gt;，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。 &lt;dependencyManagement&gt;里只是声明依赖的配置，并不自动实现引入，因此子项目需要显式声明需要用的依赖。如果不在子项目中声明依赖，是不会引入该依赖的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会引入该依赖，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么将不会使用父pom中对于该依赖的配置。前面说的是继承的方式，采用import scope依赖也遵循这个原则。 插件管理maven提供了&lt;dependencyManagement&gt;进行依赖管理，同时也提供了&lt;pluginManagement&gt;帮忙管理插件。在&lt;pluginManagement&gt;中定义的只是插件的配置，不会真的引入插件，需要显式引入才行。这跟使用&lt;dependencyManagement&gt;的道理是类似的。在父模块中定义: 1234567891011121314151617181920&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 子模块 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 通过继承的方式，子模块继承了父模块的插件管理配置，子模块中声明的插件如果没有版本号，根据groupId和artifactId去匹配插件管理的配置，如果有匹配的会将相应的配置应用到该插件。上面例子的maven-source-plugin只有声明的groupId和artifactId，那么会在插件管理中查找相应的配置，此例中，父模块中&lt;pluginManagement&gt;中可以找到匹配的插件，那么相应的配置信息也会被该插件使用。 一个项目中所有模块中使用的依赖配置应该是一样的，应该要进行统一，但插件配置很多时候是不一样的。对于插件管理，不能随便将一个插件相关的配置都提取到父模块的pom中，因为所有的子模块都会继承。一般来说，同一项目中所有模块使用的插件的版本号应该要是相同的，不然容易出错，插件版本号推荐在父模块的&lt;pluginManagement&gt;进行统一配置。对于插件的其他配置信息，只有在所有的子模块中都适用的情况下才能在父模块的&lt;pluginManagement&gt;进行统一配置。关于&lt;pluginManagement&gt;，Maven并没有提供与import scope依赖类似的方式管理，那我们只能借助继承关系，不过好在一般来说插件配置的数量远没有依赖配置那么多，因此这也不是一个问题。 参考资料 许晓斌，Maven实战（三）——多模块项目的POM重构lofty，Maven——聚合与继承","link":"/post/ffde8881.html"},{"title":"maven(二):生命周期和插件","text":"maven生命周期maven抽象出了3套生命周期，其具体实现是依赖于插件。每套生命周期是相互独立的，都由一组阶段(Phase)组成。每套生命周期中的阶段是有顺序的，后面阶段依赖于前面的阶段，执行后面阶段会自动执行之前的阶段，但不会触发不同生命周期的阶段。下面是三个生命周期及其包含的阶段。 Clean Lifecycle清理项目，在进行真正的构建之前进行一些清理工作。 pre-clean 执行clean前需要完成的工作 clean clean上一次构建生成的所有文件 post-clean 执行clean后需要立刻完成的工作 这里的clean就是指的mvn clean。在一套生命周期内，运行某个阶段会自动按序运行之前阶段，mvn clean=mvn pre-clean clean。 Default Lifecycle构建的核心部分，编译，测试，打包，部署等等。 validate 验证项目是否正确，并且所有必要的信息可用于完成构建过程 initialize 建立初始化状态，例如设置属性 generate-sources process-sources generate-resources process-resources 复制并处理资源文件，至目标目录，准备打包。 compile 编译项目的源代码。 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources 复制并处理资源文件，至目标测试目录。 test-compile 编译测试源代码。 process-test-classes test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package package 提取编译后的代码，并在其分发格式打包，如JAR，WAR或EAR文件 pre-integration-test 完成执行集成测试之前所需操作。例如，设置所需的环境 integration-test post-integration-test 完成集成测试已全部执行后所需操作。例如，清理环境 verify 运行任何检查，验证包是有效的，符合质量审核规定 install 将包安装至本地仓库，以让其它项目依赖。 deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享 Site Lifecycle生成项目报告，站点，发布站点。 pre-site 执行一些需要在生成站点文档(html)之前完成的工作 site 生成项目信息的站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 site-deploy 将生成的站点文档部署到特定的服务器上 maven插件目标maven本质是一个插件框架，maven每个生命周期的每个阶段(phase)默认绑定了一个或多个插件中的一个或多个目标。用户可以自行配置或编写插件。一个插件对应一个或多个目标，一个插件可以绑定多个生命周期阶段。 两种方式调用插件目标插件目标绑定maven生命周期阶段 这分为内置绑定和自定义绑定。 内置绑定。maven的生命周期的阶段已经默认和一些插件的目标进行了绑定。例如Maven默认将maven-compiler-plugin的compile目标与compile生命周期阶段绑定，因此命令mvn compile实际上是先定位到compile这一生命周期阶段，然后再根据绑定关系调用maven-compiler-plugin的compile目标。 自定义绑定。在pom.xml中进行配置，我们可以根据需要将任何插件目标绑定到任何生命周期的任何阶段。如：将maven-source-plugin的jar-no-fork目标绑定到default生命周期的package阶段，这样，以后在执行mvn package命令打包项目时，在package阶段之后会执行源代码打包。自定义绑定的插件目标是在绑定的生命周期阶段之后执行的 123456789101112131415161718192021&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;executions&gt; &lt;!--执行--&gt; &lt;execution&gt; &lt;id&gt;attach-source&lt;/id&gt; &lt;!-- 要绑定到的生命周期的阶段 --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;!-- 要绑定的插件的目标，在maven官网plugins上可以查到 --&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; ……&lt;/build&gt; 运行命令时直接指定插件目标(与生命周期无关)1mvn 插件目标前缀(prefix):插件目标 各插件目标的命令在官网可以查。例如mvn archetype:generate 就表示调用maven-archetype-plugin的generate目标，这种带冒号的调用方式与生命周期无关。 插件配置完成插件和生命周期的绑定后，用户还可以配置插件目标的参数，进一步调整插件目标所执行的任务，以满足项目的需求。几乎所有的Maven插件的目标都有一些可配置的参数，用户可以通过命令行和POM配置的方式来配置这些参数。 命令行插件配置用户可以在Maven命令中使用-D参数，并伴随一个参数键=参数值得形式，来配置插件目标的参数。 例如，maven-surefire-plugin提供了一个maven.test.skip参数，当其值为true的时候，就会跳过执行测试，于是在运行命令的时候，加上如下-D参数就能跳过测试。 1mvn install -Dmaven.test.skip=true 参数-D是Java自带的，其功能是通过命令行设置一个Java系统属性，Maven简单的重用了该参数，在准备插件的时候检查系统属性，便实现了插件参数的配置。 在POM中插件全局配置并不是所有的插件参数都适合从命令行配置，有些参数的值从项目创建到项目发布都不会改变，或者说很少改变，对于这种情况，在POM文件中一次性配置就显然比重负在命令行输入要方便。 用户可以在声明插件的时候，对此插件进行一个全局配置。也就是说，所有该基于该插件目标的任务，都会使用这些配置。例如我们通常会需要配置maven-compiler-plugin告诉它配置Java1.5版本的源文件，生成与JVM1.5兼容的字节码文件，代码如下： 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artfactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.5&lt;/source&gt; &lt;target&gt;1.5&lt;/target&gt; &lt;/configration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 这样，不管绑定到compile阶段的maven-compiler-plugin:compile任务，还是绑定到test-compiler阶段的maven-compiler-plugin:testCompiler任务，这都能够使用该配置，基于Java1.5版本进行编译。 POM中插件任务配置除了为插件配置全局的参数，用户还可以为某个插件任务配置特定的参数。以maven-antrun-plugin为例，它有一个目标run,可以用来在Maven中调用Ant任务。用户将maven-antrun-plugin:run绑定到多个生命周期阶段上，再加以不同的配置，就可以让Maven在不同的生命周期执行不同的任务，代码如下: 123456789101112131415161718192021222324252627282930313233&lt;build&gt; &lt;plugins&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;ant-validate&lt;/id&gt; &lt;phase&gt;validate&lt;phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;echo&gt;Im'bound to validate phase&lt;/echo&gt; &lt;/tasks&gt; &lt;/configurationo&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;ant-verify&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;echo&gt;I'm bound to verify phase&lt;/echo&gt; &lt;/tasks&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugins&gt;&lt;/build&gt; 上述代码片段中，首先，maven-antrun-plugin:run与validate绑定，从而构成一个id为ant-validate的任务。插件全局配置中的configuration元素位于plugin元素下面，而这里的configuration元素则位于execution元素下，表示这是特定任务的配置，而非插件整体的配置。这个ant-validate任务配置了一个echo Ant任务，向命令行输出一段文字，表示该任务是绑定到validate阶段的。第二个任务的id为ant-verify，它绑定到了verify阶段，同样它也输出一段文字到命令行，告诉该任务绑定到了verify阶段。 获取插件信息仅仅理解如何配置和使用插件是不够的，当遇到一个构建任务的时候，用户还需要知道去哪里寻找合适的插件，以帮助完成任务，找到正确的插件之后，还要详细了解该插件的配置点。由于Maven的插件非常多，这其中大部分没有完善文档，因此，使用正确的插件并进行正确的配置，其实并不是一件容易的事。 在线插件信息基本所有的主要的Maven插件都来自Apache和Codehaus。由于Maven本身是属于Apache软件基金会的，因此他有很多的官方的插件，每天都有成千上万的Maven用户在使用这些插件，他们具有非常好的的稳定性。官网插件介绍插件列表 使用maven-help-plugin描述插件除了访问在线的插件文档之外，还可以借助maven-help-plugin来获取插件的详细信息。。可以运行一下命令来获取maven-compiler-plugin2.1版本的信息： 1mvn help:describe-Dplugin=org.apache.maven.plugins:maven-compiler-plugin:2.1 这里执行的是maven-help-plugins的describe目标，在参数的plugin中输入需要描述插件的groupId、artfactId和version。Maven在命令行输出maven-compiler-plugin的简要信息。 在描述插件的时候，还可以省去版本信息，让Maven自动获取最新版本来进行表述。例如： 1mvn help:describe-Dplugin=org.apache.maven.plugins:maven-compiler-plugin 进一步简化，可以使用插件目标前缀替换坐标。例如： 1mvn help:describe-Dplugin=compiler 如果仅仅想描述某个插件目标的信息，可以加上goal参数： 1mvn help:describe-Dplugin=compiler-Dgoal=compile 如果想让maven-help-plugin输出更详细的信息，可以加上detail参数： 1mvn help:describe -Dplugin=compiler-Ddetail 从命令行调用插件如果在命令行运行mvn -h来显示mvn命令帮助，可以看到如下的信息： 12345678910usage: mvn [options] [&lt;goal(s)&gt;] [&lt;phase(s)&gt;] Options: -am,--also-make If project list is specified, also build projects required by the list -amd,--also-make-dependents If project list is specified, also build projects that depend on... 该信息告诉了我们mvn命令的基本用法，options表示可用的选项，mvn命令有20多个选项，除了选项之外，mvn命令后面可以添加一个或者多个goal和phase，他们分别是指插件目标和生命周期阶段 可以通过mvn命令激活生命周期阶段，从而执行那些绑定在生命周期阶段上的插件目标。但Maven还支持直接从命令行调用插件目标。Maven支持这种方式是因为有些任务不适合绑定在生命周期上，例如maven-help-plugin:describe，我们不需要在构建项目的时候去描述插件信息，又如maven-dependency-plugin:tree,我们也不需要在构建项目的时候去显示依赖树，因此这些插件目标应该通过如下方式使用： 12mvn help:describe-Dplugin=compilermvn dependency:tree 不过这里有个疑问，describe是maven-help-plugin的目标没错，但是冒号前面的help是什么呢？它既不是groupId，也不是artifactId,Maven是如何根据该信息找到对应版本插件的呢？同理为什么不是maven-dependency-plugin:tree,而是dependency:tree 解答该疑问之前，可以尝试一下如下命令： 123mvn org.apache.maven.plugins:maven-help-plugin:2.1:describe-Dplugin=compilermvn org.apache.maven.plugins:maven-dependency-plugin:2.1:tree 这两条命令就比较容易理解了，插件的groupId、artifactId、version以及goal都得以清晰描述。它们的效果与之前的两条命令基本是一样的，但是显然前面的命令更简洁，更容易记忆和使用。为了达到该目的，Maven引入了目标前缀的概念help是maven-help-plugin的目标前缀，dependency是maven-dependency-plugin的前缀，有了插件前缀，Maven就能找到对应的artifactId。不过，除了artifactId,Maven还需要得到groupId和version才能精确定位到某个插件。 插件解析机制仓库元数据插件元数据主要用于解释插件版本 在远程仓库存放的位置结构:http://repo1.maven.org/maven2/groupId/artifactId/maven-metadata.xml 这里的groupId指的就是构件的groupId，artifactId指的是构件的artifactId，例如插件maven-compiler-plugin的元数据链接:http://repo1.maven.org/maven2/org/apache/maven/plugins/maven-compiler-plugin/maven-metadata.xml内容如下： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;metadata&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;versioning&gt; &lt;latest&gt;3.7.0&lt;/latest&gt; &lt;release&gt;3.7.0&lt;/release&gt; &lt;versions&gt; &lt;version&gt;2.0-beta-1&lt;/version&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;version&gt;3.5&lt;/version&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;version&gt;3.6.0&lt;/version&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;version&gt;3.6.2&lt;/version&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/versions&gt; &lt;lastUpdated&gt;20170904193138&lt;/lastUpdated&gt; &lt;/versioning&gt;&lt;/metadata&gt; 插件前缀元数据主要用于解释插件前缀 在远程仓库存放的位置结构:http://repo1.maven.org/maven2/groupId/maven-metadata.xml 我们使用一般使用官方的插件就够了，官方插件默认的groupId为org.apache.maven.plugins，对应的链接为http://repo1.maven.org/maven2/org/apache/maven/plugins/maven-metadata.xml下面是前缀元数据xml文件截取的部分内容 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;metadata&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;name&gt;Apache Maven ACR Plugin&lt;/name&gt; &lt;prefix&gt;acr&lt;/prefix&gt; &lt;artifactId&gt;maven-acr-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;name&gt;Apache Maven Ant Plugin&lt;/name&gt; &lt;prefix&gt;ant&lt;/prefix&gt; &lt;artifactId&gt;maven-ant-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;name&gt;Maven ANTLR Plugin&lt;/name&gt; &lt;prefix&gt;antlr&lt;/prefix&gt; &lt;artifactId&gt;maven-antlr-plugin&lt;/artifactId&gt; &lt;/plugin&gt; …… &lt;/plugins&gt;&lt;/metadata&gt; 插件仓库与依赖仓库一样，插件构件同样基于坐标存储在Maven仓库中，在需要的时候Maven会从本地仓库查找插件，如果不存在，则从远程仓库查找。找到插件之后，再下载到本地仓库使用。 需要注意的是，Maven会区别对待依赖的远程仓库与插件的远程仓库。前面提到如何配置远程仓库，但是这种配置只对一般依赖有效果，当Maven需要的依赖在本地仓库不存在时，它会去所配置的远程仓库中查找，可是当Maven需要的插件在本地仓库存在时，他就不会去那些远程仓库查找。 不同于repositories及其repository子元素，插件的远程仓库使用pluginRepositories和pluginReposirory配置，例如，Maven的超级pom:pom-4.0.0.xml配置了如下的插件远程仓库,代码如下： 1234567891011121314&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Plugin Repository&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;snapshots&gt; &lt;releases&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 一般来说，中央仓库所包含的插件完全能够满足我们的需要，因此也不需要配置其他的插件仓库。只有在很少的情况下，项目使用的插件无法在中央仓库找到，或者自己编写的插件，这个时候可以参考上述的配置，在POM或者settings.xml中加入其他的插件仓库配置。 插件的默认groupId在POM配置中配置插件的时候，如果该插件是Maven的官方插件（即如果其groupId为org.apache.maven.plugins），就可以省略groupId配置，见代码清单： 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.5&lt;/source&gt; &lt;target&gt;1.5&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 上面省略了配置maven-compiler-plugin的groupId，Maven在解析该插件的时候，会自动用默认groupId org.apache.maven.plugins补齐。但是并不推荐使用Maven的这一机制，这样虽然可以省略一些配置，但是这样的配置会让团队中不熟悉Maven的成员感到费解，况且能省略的配置也就仅仅一行而已。 解析插件版本 同样是为了简化插件的配置和使用，在用户没有提供插件版本的情况下，Maven会自动解析插件版本。首先，Maven的超级POM中为所有核心插件设定了版本,超级POM是所有Maven项目的父POM，所有项目都会继承这个超级POM配置，因此，即使用户不加任何配置，Maven使用核心插件的时候，他们的版本都已经确定了，这些插件包括maven-clean-plugin、maven-compiler-plugin、maven-surefire-plugin等。 上面说法是来自其他博客，我表示质疑，我使用的是maven3.5.4，在超级pom中并没有发现其为所有核心插件设定了版本。这点不明白，以后搞清楚再补充。 如果用户使用某个插件时没有设定版本，而这个插件又不属于核心插件范畴，Maven就会去检查所有仓库中的可用版本，然后做出选择。以maven-compiler-plugin为例，他在中央仓库的仓库元数据 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;metadata&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;versioning&gt; &lt;latest&gt;3.7.0&lt;/latest&gt; &lt;release&gt;3.7.0&lt;/release&gt; &lt;versions&gt; &lt;version&gt;2.0-beta-1&lt;/version&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;version&gt;3.5&lt;/version&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;version&gt;3.6.0&lt;/version&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;version&gt;3.6.2&lt;/version&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/versions&gt; &lt;lastUpdated&gt;20170904193138&lt;/lastUpdated&gt; &lt;/versioning&gt;&lt;/metadata&gt; Maven遍历本地仓库和所有远程插件仓库，将该路径下的仓库元数据归并后，就能计算出latest和release的值。latest表示所有仓库中该构件的最新版本，而release表示最新的非快照版本。在Maven2中，插件的版本会被解析至latest。也就是说，当用户使用某个非核心插件且没有声明版本的时候，Maven会将版本解析为所有可用仓库中的最新版本，而这个版本也可能是快照版本的。 当插件的版本为快照版本的时，就会出现潜在的问题。Maven会基于更新策略，检查并使用快照的更新。某个插件可能昨天还好好的，今天就出错了。其原因是因为这个版本的插件发生了变化，为了防止这类问题，Maven3调整了解析机制，当插件没有声明版本的时候，不再解析至latest，而是使用release。这样就可以避免由于快照频繁更新而导致的插件行为不稳定。 依赖Maven解析插件版本其实是不推荐的做法，即使Maven3将版本解析到最新的非快照版本，也还是唯有潜在的不稳定性。例如，可能某个构件发布了一个新的版本，而这个版本的行为与之前的的版本发生了变化，这种变化就可能导致项目构建失败。因此，使用插件的时候，应该一直显式的设定版本，这也解释了Maven为什么要在超级POM中为核心插件设定版本。 解析插件前缀mvn命令行支持使用插件前缀来简化插件的调用，现在解释Maven如何根据插件前缀解析到插件的坐标的。 插件前缀与groupId:artifactId是一一对应的，这种匹配关系存储在仓库元数据中。这里的仓库元数据不是groupId/artifactId/maven-metadata.xml，而是groupId/maven-metadata.xml。当Maven解析前缀: 首先会基于默认的groupId(org.apache.maven.plugins)归并所有插件仓库的元数据org/apache/maven/plugins/maven-metadata.xml 其次检查归并后的元素，根据前缀(prefix)找到对应的artifactId； 结合artifactId和groupId，最后获取version，这是就得到了完整的插件坐标。 若org/apache/maven/plugins/maven-metadata.xml没有记录该插件前缀，则接着检查其他groupId下的元数据，如org/codehaus/mojo/maven-metadata.xml以及用户自定义的插件。若所有元数据都不包含该前缀，则报错。 插件前缀元数据部分内容: 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;metadata&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;name&gt;Apache Maven ACR Plugin&lt;/name&gt; &lt;prefix&gt;acr&lt;/prefix&gt; &lt;artifactId&gt;maven-acr-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;name&gt;Apache Maven Ant Plugin&lt;/name&gt; &lt;prefix&gt;ant&lt;/prefix&gt; &lt;artifactId&gt;maven-ant-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;name&gt;Maven ANTLR Plugin&lt;/name&gt; &lt;prefix&gt;antlr&lt;/prefix&gt; &lt;artifactId&gt;maven-antlr-plugin&lt;/artifactId&gt; &lt;/plugin&gt; …… &lt;/plugins&gt;&lt;/metadata&gt; 参考资料 321笨丫头,maven install、maven clean、project clean lofty,Maven——生命周期与插件","link":"/post/fa942646.html"},{"title":"maven(五):聚合和继承","text":"聚合Maven聚合（或者称为多模块），是为了能够使用一条命令就构建多个模块，方便快速构建项目，例如已经有两个模块，分别为A,B，我们需要创建一个额外的模块（假设名字为aggregator，然后通过该模块，来构建整个项目的所有模块，aggregator本身作为一个Maven项目，它必须有自己的POM,不过作为一个聚合项目，其POM又有特殊的地方，看下面的配置123456789101112131415&lt;projectxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yangyuanming&lt;/groupId&gt; &lt;artifact&gt;aggregator&lt;/artifact&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;Aggregator&lt;/name&gt; &lt;modules&gt; &lt;module&gt;../A&lt;/module&gt; &lt;module&gt;../B&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 必须声明&lt;packaging&gt;为pom，对于聚合模块来说，其打包方式必须为pom，否则无法构建。&lt;modules&gt;里的每一个&lt;module&gt;都可以用来指定一个被聚合模块，这里每个&lt;module&gt;的值都是一个当前pom的相对位置，本例中A、B和aggregator位于同一级目录下。 继承为了消除多模块项目中的重复配置，类似于java，maven中也有继承，一次声明，多次使用。父项目的pom.xml声明的配置，子项目pom.xml不需要声明就可以直接使用，子项目的配置可以覆盖父项目的配置。很多时候，我们使用继承主要是为了方便管理引用的构件(依赖和插件)。一个项目往往分为很多模块，而不同的模块中，引用的构件很多是一样的，使用继承就避免了在不同模块中重复引用的问题，同时也方便统一管理构件，构件版本号统一。 继承示例 父模块pom.xml 12345678910111213141516171819&lt;projectxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:shemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yangyuanming&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;Parent&lt;/name&gt; &lt;dependencies&gt; .... &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; .... &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; &lt;packaging&gt;的值必须为pom，由于父模块只是为了帮助消除配置的重复，因此它本身不包含除POM之外的项目文件，可以把项目中src/main/java和src/test/java目录删除。继承的是父模块的pom.xml。 子模块pom.xml1234567891011121314151617181920212223&lt;project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:shemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;parent&gt; &lt;groupId&gt;com.yangyuanming&lt;groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;name&gt;artifactId-A&lt;/name&gt; &lt;dependencies&gt; .... &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; .... &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 上面POM中使用parent元素声明父模块，paren下的子元素groupId、artifactId和version指定了父模块的坐标，这三个元素是必须的。元素relativePath表示了父模块POM的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。当项目构建时，Maven会首先根据relativePath检查父pom，然后在本地仓库，最后在远程仓库寻找父项目的pom。此例子父模块parent和子模块在同一级目录下。 子模块会自动继承父模块的配置，子模块配置会覆盖从父模块继承来的配置。上面子模块child没有声明groupId，version，因为这个子模块隐式的从父模块继承了这两个元素，这也就消除了不必要的配置。上例中，父子模块使用了相同的groupId和version，如果遇到子模块需要使用和父模块不一样的groupId或者version的情况，可以在子模块中显式声明。子模块会自动继承父模块的插件和依赖，不需要再重新显式引入，这大大方便了多模块开发的管理。然而所有的子模块会将父pom.xml中定义的所有构件继承下来，不同模块所需的构件还是会有一点差别的，存在继承多余构件的问题，怎么办呢？看下一篇文章吧！ 可继承的pom元素 groupId:项目组ID,项目坐标的核心元素 version:项目版本,项目坐标的核心元素 description:项目的描述信息 organnization:项目的组织信息 inceptionYear:项目的创始年份 url:项目的URL地址 developers:项目的开发者信息 contributors:项目的贡献者信息 distributionManagement:项目的部署配置 issueManagement:项目的缺陷跟踪系统信息 ciManagement:项目的集成信息 scm:项目的版本控制系统信息 mailingLists:项目的邮件列表信息 properties:自定义的Maven属性 dependencies:项目的依赖配置 dependencyManagement:项目的依赖管理配置 repositories:项目的仓库配置 build:包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等 reporting:包括项目的报告输出目录配置，报告插件配置等。 参考资料 lofty，Maven——聚合与继承","link":"/post/86efede5.html"},{"title":"maven(四):依赖","text":"依赖的配置 12345678910111213141516171819202122&lt;projectxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:shemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd\"&gt; ...... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt; &lt;type&gt;...&lt;/type&gt; &lt;scope&gt;...&lt;/scope&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;optional&gt;...&lt;optional&gt; &lt;exclusions&gt; &lt;exclusion&gt;...&lt;/exclusion&gt; &lt;/exclusions&gt; .... &lt;/dependency&gt; &lt;/dependencies&gt; .........&lt;/project&gt; groupId、artifactId、version：构成依赖的基本坐标 type：依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。对应于项目坐标中的packaging scope：依赖范围，默认compile，作用是控制依赖和3种classpath的关系，另外还会影响依赖传递，maven官方介绍。maven3种classpath:编译、运行、测试，各依赖范围与classpath的关系如下 compile:编译依赖范围。如果没有指定，就会默认使用该依赖范围，使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。此外，这些依赖关系会传播到依赖项目。 test:测试依赖范围。使用该范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是JUnit,它只是在编译测试代码和运行测试的时候需要该依赖。这个范围是不可传递的。 provided：已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试的classpath有效，但是在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要改依赖，但是在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。该依赖不可传递。 runtime:运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但是编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在测试或者运行项目的时候才需要实现上述接口的JDBC驱动。 import(Maven 2.0.9及以上)：导入依赖范围。仅限于在中引入的依赖，依赖的类型必须为pom，才能声明scope为import。对于被导入的pom也必须配置有 ,配置有对依赖的管理。该依赖范围不会对三种classpath产生实际的影响,不参与限制依赖关系的传递性。引进方其实引进的是被引进方pom.xml中的配置。 system:系统依赖范围，该范围与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显式的指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析，而且往往与本机系统绑定，可能造成构建的不可移植，因此需要谨慎使用。systemPath元素可以引用环境变量，如： 1234567&lt;dependency&gt; &lt;groupId&gt;javax.sql&lt;/groupId&gt; &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${java.home}/lib/rt.jar&lt;/systemPath&gt;&lt;/dependency&gt; 除import外，各依赖和3种classpath的关系如下 依赖范围 编译 测试 运行 例子 compile Y Y Y spring-core test - Y - junit provided Y Y - servlet-api runtime - Y Y JDBC驱动实现 system Y Y - 本地的，Maven仓库之外的类库文件 systemPath：仅供scope为system时使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 optional：可选依赖，控制依赖的可传递性。如果为true，则其子项不会引入该依赖。如果子项要引用该依赖，需要显式引用。 exclusions：用于排除传递性依赖。A引入依赖B，而B依赖C，由于依赖会传递，A也会引入依赖C。如果A不想引入依赖C，则可以在引入B依赖时设置exclusion，排除传递依赖C。 依赖传递例子解释maven项目中可能会存在依赖多层引用，例如项目A依赖B,B依赖n个其他项目，A不需要手动再引用B所依赖的n个项目。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目当中。 传递性依赖和依赖范围每个作用域(除了import )以不同的方式影响传递依赖关系，如下表所示。如果将依赖项设置为左列中的范围，则该依赖项与顶部行中的范围的传递依赖项将导致主项目中的依赖项与交叉列出的范围。如果没有列出范围，这意味着将省略相关性。 compile provided runtime test compile compile - runtime - provided provided - provided - runtime runtime - runtime - test test - test - 依赖冲突maven的传递性依赖方便了我们开发，一般我们只关心直接依赖而不会关心传递依赖。但当传递性依赖发生问题时，我们需要清楚传递性依赖的来源。传递性依赖是可能存在冲突的，比如某个依赖路径可能存在多个相同依赖，只是版本号不同，那么使用哪个传递依赖呢？maven遵循两个原则： 第一原则：短路优先例如，项目A存在以下传递依赖A--&gt;B--&gt;C--&gt;D(1.0)A--&gt;C--&gt;D(2.0)根据第一原则，项目A会使用D(2.0) 第二原则：声明优先有时候存在路径长度相同的情况，这时遵循第二原则A--&gt;B--&gt;D(1.0)A--&gt;C--&gt;D(2.0)假设A--&gt;B--&gt;D(1.0)先声明，那么项目A会使用D(1.0) 可选依赖可选依赖是由&lt;dependency&gt;中的&lt;optional&gt;标签定义的，默认为false，如果声明为&lt;optional&gt;true&lt;/optional&gt;,那么子项目将不会隐式引入该依赖，如果需要引入，需要在子项目的pom.xml中显式引入。为什么需要设置可选依赖？可能项目A实现了两个特性，其中的特性一依赖于X，特性二依赖于Y,而且这两个特性是互斥的，用户不可能同时使用两个特性。比如A是一个持久层隔离工具包，它支持多种数据库，报错MySQL、Oracle,在构建这个工具包的时候，需要这两种数据库的驱动程序，但是在使用这个工具包的时候，只会依赖一种数据库。在理想的情况下，是不应该使用可选依赖的。除非是某一个项目实现了多个互斥的特性，在面向对象设计中，有个单一职责性原则，意指一个类应该只要一项职责。 排除传递依赖传递性依赖会给项目隐式引入很多依赖，大大方便了依赖的管理，但有时候会带来问题。例如存在以下依赖传递：A--&gt;B--&gt;C由于传递依赖C是SNAPSHOT版本，引入C会给项目A带来问题，实际上C存在release版的，引入release版的对C没有问题，这时就需要在引入依赖B的声明中排除C(SNAPSHOT),然后再显式引入C(release)。 1234567891011121314151617181920212223&lt;groupId&gt;com.yangyuanming&lt;/groupId&gt;&lt;artifactId&gt;project-A&lt;/artifactId&gt;&lt;version&gt;1.0.0&lt;/version&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.yangyuanming&lt;/groupId&gt; &lt;artifactId&gt;project-B&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!--排除传递依赖--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.yangyuanming&lt;/groupId&gt; &lt;artifactId&gt;project-C&lt;/artfactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--显式引入所需的依赖C稳定版--&gt; &lt;dependency&gt; &lt;groupId&gt;com.yangyuanming&lt;/groupId&gt; &lt;artifactId&gt;project-C&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 上述代码中，项目A在引入依赖B时，使用&lt;exclusion&gt;排除了传递依赖C，然后再显式引入了另一个版本的依赖C。也可能存在其他原因不想引入某个传递性依赖，可以在&lt;exclusions&gt;中声明多个&lt;exclusion&gt;排除多个传递依赖。声明&lt;exclusion&gt;时只需要指明&lt;groupId&gt;和&lt;artifactId&gt; 归并依赖来自A项目的不同模块，版本号是相同的。当B项目需要引入A项目的多个模块时，一般要保证引入A项目的多个模块的版本号是相同的，为了方便B项目管理引入的多个模块(A项目)，需要做归并处理。举个例子，Spring Framework包含很多模块，例如core:2.5.6、bean:2.5.6、context:2.5.6和support:2.5.6,他们来着同一项目的不同模块，因此，所有这些依赖的版本都是相同的，而且，如果以后需要升级Spring Framework，这些依赖的版本会一起升级，这样我们就可以像Java中声明一个Constants一样，为依赖的项目的版本设置一个这样类似常量的东西。这样在升级Spring Framework的时候就需要修改一处，代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;projectxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:shemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yangyuanming&lt;/groupId&gt; &lt;artfactId&gt;blog_v3&lt;/artifactId&gt; &lt;name&gt;blog&lt;/name&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;springframework.version&gt;2.5.6&lt;/springframework.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifact&gt;spring-core&lt;/artifact&gt; &lt;version&gt;${springframework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifact&gt;spring-beans&lt;/artifact&gt; &lt;version&gt;${springframework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifact&gt;spring-context&lt;/artifact&gt; &lt;version&gt;${springframework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifact&gt;spring-context-support&lt;/artifact&gt; &lt;version&gt;${springframework.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 上面代码定义maven属性，定义了一个&lt;springframework.version&gt;，指定Spring Framework的版本号，然后在引入的依赖的&lt;version&gt;中引用该属性，达到统一管理版本号的作用。 优化依赖查看已解析依赖可以使用命令，如下： 列表形式查看命令：mvn dependency:list 树状结构查看命令：mvn dependency:tree 依赖分析命令：mvn dependency:analyzemvn dependency:analyze由两部分组成，首先是Used updeclared dependencies,意指项目中使用到的，没有显式声明的依赖。其次是Unused declared dependencies，意指项目中没有使用的，但是显是声明了的依赖。需要注意的是，对于这一类依赖，我们不应该简单的直接删除其声明，而是应该仔细分析，由于dependency:analyze只会分析编译主代码和测试代码需要用到的依赖，一些执行测试和运行时需要的依赖它就发现不了。建议不要乱删，当然有时候确实能通过该信息找到一些没用的依赖，但一定要小心测试。 参考资料 lofty，Maven——坐标与依赖Introduction to the Dependency Mechanism","link":"/post/7e899530.html"}],"tags":[{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"maven构建命令","slug":"maven构建命令","link":"/tags/maven构建命令/"},{"name":"maven库","slug":"maven库","link":"/tags/maven库/"},{"name":"pom.xml","slug":"pom-xml","link":"/tags/pom-xml/"},{"name":"maven依赖&插件管理","slug":"maven依赖-插件管理","link":"/tags/maven依赖-插件管理/"},{"name":"maven生命周期","slug":"maven生命周期","link":"/tags/maven生命周期/"},{"name":"maven插件","slug":"maven插件","link":"/tags/maven插件/"},{"name":"maven聚合&继承","slug":"maven聚合-继承","link":"/tags/maven聚合-继承/"},{"name":"maven依赖","slug":"maven依赖","link":"/tags/maven依赖/"}],"categories":[{"name":"工具学习","slug":"工具学习","link":"/categories/工具学习/"},{"name":"maven","slug":"工具学习/maven","link":"/categories/工具学习/maven/"}]}